<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>pandas_profiling.model.describe API documentation</title>
<meta name="description" content="Compute statistical description of datasets." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pandas_profiling.model.describe</code></h1>
</header>
<section id="section-intro">
<p>Compute statistical description of datasets.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Compute statistical description of datasets.&#34;&#34;&#34;
import multiprocessing.pool
import multiprocessing
import itertools
import os
import warnings
from pathlib import Path
from typing import Tuple
from urllib.parse import urlsplit

import numpy as np
import pandas as pd
from astropy.stats import bayesian_blocks
from scipy.stats.stats import chisquare

from pandas_profiling import __version__
from pandas_profiling.config import config as config
from pandas_profiling.model.messages import (
    check_variable_messages,
    check_table_messages,
    warning_type_date,
    check_correlation_messages,
)

from pandas_profiling.model import base
from pandas_profiling.model.base import Variable
from pandas_profiling.model.correlations import calculate_correlations
from pandas_profiling.visualisation.missing import (
    missing_bar,
    missing_matrix,
    missing_heatmap,
    missing_dendrogram,
)
from pandas_profiling.visualisation.plot import scatter_pairwise


def describe_numeric_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a numeric series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.

    Notes:
        When &#39;bins_type&#39; is set to &#39;bayesian_blocks&#39;, astropy.stats.bayesian_blocks is used to determine the number of
        bins. Read the docs:
        https://docs.astropy.org/en/stable/visualization/histogram.html
        https://docs.astropy.org/en/stable/api/astropy.stats.bayesian_blocks.html

        This method might print warnings, which we suppress.
        https://github.com/astropy/astropy/issues/4927
    &#34;&#34;&#34;
    quantiles = config[&#34;vars&#34;][&#34;num&#34;][&#34;quantiles&#34;].get(list)

    stats = {
        &#34;mean&#34;: series.mean(),
        &#34;std&#34;: series.std(),
        &#34;variance&#34;: series.var(),
        &#34;min&#34;: series.min(),
        &#34;max&#34;: series.max(),
        &#34;kurtosis&#34;: series.kurt(),
        &#34;skewness&#34;: series.skew(),
        &#34;sum&#34;: series.sum(),
        &#34;mad&#34;: series.mad(),
        &#34;n_zeros&#34;: (len(series) - np.count_nonzero(series)),
        &#34;histogram_data&#34;: series,
        &#34;scatter_data&#34;: series,  # For complex
    }

    chi_squared_threshold = config[&#34;vars&#34;][&#34;num&#34;][&#34;chi_squared_threshold&#34;].get(float)
    if chi_squared_threshold &gt; 0.0:
        histogram = np.histogram(series[series.notna()].values, bins=&#34;auto&#34;)[0]
        stats[&#34;chi_squared&#34;] = chisquare(histogram)

    stats[&#34;range&#34;] = stats[&#34;max&#34;] - stats[&#34;min&#34;]
    stats.update(
        {
            &#34;{:.0%}&#34;.format(percentile): value
            for percentile, value in series.quantile(quantiles).to_dict().items()
        }
    )
    stats[&#34;iqr&#34;] = stats[&#34;75%&#34;] - stats[&#34;25%&#34;]
    stats[&#34;cv&#34;] = stats[&#34;std&#34;] / stats[&#34;mean&#34;] if stats[&#34;mean&#34;] else np.NaN
    stats[&#34;p_zeros&#34;] = float(stats[&#34;n_zeros&#34;]) / len(series)

    bins = config[&#34;plot&#34;][&#34;histogram&#34;][&#34;bins&#34;].get(int)
    # Bins should never be larger than the number of distinct values
    bins = min(series_description[&#34;distinct_count_with_nan&#34;], bins)
    stats[&#34;histogram_bins&#34;] = bins

    bayesian_blocks_bins = config[&#34;plot&#34;][&#34;histogram&#34;][&#34;bayesian_blocks_bins&#34;].get(bool)
    if bayesian_blocks_bins:
        with warnings.catch_warnings():
            warnings.simplefilter(&#34;ignore&#34;)
            ret = bayesian_blocks(stats[&#34;histogram_data&#34;])

            # Sanity check
            if not np.isnan(ret).any() and ret.size &gt; 1:
                stats[&#34;histogram_bins_bayesian_blocks&#34;] = ret

    return stats


def describe_date_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a date series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;
    stats = {&#34;min&#34;: series.min(), &#34;max&#34;: series.max(), &#34;histogram_data&#34;: series}

    bins = config[&#34;plot&#34;][&#34;histogram&#34;][&#34;bins&#34;].get(int)
    # Bins should never be larger than the number of distinct values
    bins = min(series_description[&#34;distinct_count_with_nan&#34;], bins)
    stats[&#34;histogram_bins&#34;] = bins

    stats[&#34;range&#34;] = stats[&#34;max&#34;] - stats[&#34;min&#34;]

    return stats


def describe_categorical_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a categorical series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;
    # Make sure we deal with strings (Issue #100)
    series = series.astype(str)

    # Only run if at least 1 non-missing value
    value_counts = series_description[&#34;value_counts_without_nan&#34;]

    stats = {&#34;top&#34;: value_counts.index[0], &#34;freq&#34;: value_counts.iloc[0]}

    chi_squared_threshold = config[&#34;vars&#34;][&#34;num&#34;][&#34;chi_squared_threshold&#34;].get(float)
    if chi_squared_threshold &gt; 0.0:
        stats[&#34;chi_squared&#34;] = list(chisquare(value_counts.values))

    check_composition = config[&#34;vars&#34;][&#34;cat&#34;][&#34;check_composition&#34;].get(bool)
    if check_composition:
        contains = {
            &#34;chars&#34;: series.str.contains(r&#34;[a-zA-Z]&#34;, case=False, regex=True).any(),
            &#34;digits&#34;: series.str.contains(r&#34;[0-9]&#34;, case=False, regex=True).any(),
            &#34;spaces&#34;: series.str.contains(r&#34;\s&#34;, case=False, regex=True).any(),
            &#34;non-words&#34;: series.str.contains(r&#34;\W&#34;, case=False, regex=True).any(),
        }

        stats[&#34;length&#34;] = series.str.len()
        stats[&#34;max_length&#34;] = series.str.len().max()
        stats[&#34;mean_length&#34;] = series.str.len().mean()
        stats[&#34;min_length&#34;] = series.str.len().min()
        stats[&#34;composition&#34;] = contains

    stats[&#34;date_warning&#34;] = warning_type_date(series)

    return stats


def describe_url_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a url series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;
    # Make sure we deal with strings (Issue #100)
    series = series[~series.isnull()].astype(str)

    stats = {}

    # Create separate columns for each URL part
    keys = [&#34;scheme&#34;, &#34;netloc&#34;, &#34;path&#34;, &#34;query&#34;, &#34;fragment&#34;]
    url_parts = dict(zip(keys, zip(*series.map(urlsplit))))
    for name, part in url_parts.items():
        stats[&#34;{}_counts&#34;.format(name.lower())] = pd.Series(
            part, name=name
        ).value_counts()

    # Only run if at least 1 non-missing value
    value_counts = series_description[&#34;value_counts_without_nan&#34;]

    stats[&#34;top&#34;] = value_counts.index[0]
    stats[&#34;freq&#34;] = value_counts.iloc[0]

    return stats


def describe_path_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a path series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;
    series_description.update(describe_categorical_1d(series, series_description))

    # Make sure we deal with strings (Issue #100)
    series = series[~series.isnull()].astype(str)
    series = series.map(Path)

    common_prefix = os.path.commonprefix(list(series))
    if common_prefix == &#34;&#34;:
        common_prefix = &#34;No common prefix&#34;

    stats = {&#34;common_prefix&#34;: common_prefix}

    # Create separate columns for each path part
    keys = [&#34;stem&#34;, &#34;suffix&#34;, &#34;name&#34;, &#34;parent&#34;]
    path_parts = dict(
        zip(keys, zip(*series.map(lambda x: [x.stem, x.suffix, x.name, x.parent])))
    )
    for name, part in path_parts.items():
        stats[&#34;{}_counts&#34;.format(name.lower())] = pd.Series(
            part, name=name
        ).value_counts()

    # Only run if at least 1 non-missing value
    value_counts = series_description[&#34;value_counts_without_nan&#34;]

    stats[&#34;top&#34;] = value_counts.index[0]
    stats[&#34;freq&#34;] = value_counts.iloc[0]

    return stats


def describe_boolean_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a boolean series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;
    value_counts = series_description[&#34;value_counts_without_nan&#34;]

    stats = {&#34;top&#34;: value_counts.index[0], &#34;freq&#34;: value_counts.iloc[0]}

    return stats


def describe_supported(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a supported series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;

    # number of observations in the Series
    leng = len(series)
    # TODO: fix infinite logic
    # number of non-NaN observations in the Series
    count = series.count()
    # number of infinite observations in the Series
    n_infinite = count - series.count()

    # TODO: check if we prefer without nan
    distinct_count = series_description[&#34;distinct_count_with_nan&#34;]

    stats = {
        &#34;n&#34;: leng,
        &#34;count&#34;: count,
        &#34;distinct_count&#34;: distinct_count,
        &#34;n_unique&#34;: distinct_count,
        &#34;p_missing&#34;: 1 - count * 1.0 / leng,
        &#34;n_missing&#34;: leng - count,
        &#34;p_infinite&#34;: n_infinite * 1.0 / leng,
        &#34;n_infinite&#34;: n_infinite,
        &#34;is_unique&#34;: distinct_count == leng,
        &#34;mode&#34;: series.mode().iloc[0] if count &gt; distinct_count &gt; 1 else series[0],
        &#34;p_unique&#34;: distinct_count * 1.0 / leng,
        &#34;memory_size&#34;: series.memory_usage(),
    }

    return stats


def describe_unsupported(series: pd.Series, series_description: dict):
    &#34;&#34;&#34;Describe an unsupported series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;

    # number of observations in the Series
    leng = len(series)
    # number of non-NaN observations in the Series
    count = series.count()
    # number of infinte observations in the Series
    n_infinite = count - series.count()

    results_data = {
        &#34;n&#34;: leng,
        &#34;count&#34;: count,
        &#34;p_missing&#34;: 1 - count * 1.0 / leng,
        &#34;n_missing&#34;: leng - count,
        &#34;p_infinite&#34;: n_infinite * 1.0 / leng,
        &#34;n_infinite&#34;: n_infinite,
        &#34;memory_size&#34;: series.memory_usage(),
    }

    return results_data


def describe_1d(series: pd.Series) -&gt; dict:
    &#34;&#34;&#34;Describe a series (infer the variable type, then calculate type-specific values).

    Args:
        series: The Series to describe.

    Returns:
        A Series containing calculated series description values.
    &#34;&#34;&#34;

    # Replace infinite values with NaNs to avoid issues with histograms later.
    series.replace(to_replace=[np.inf, np.NINF, np.PINF], value=np.nan, inplace=True)

    # Infer variable types
    series_description = base.get_var_type(series)

    # Run type specific analysis
    if series_description[&#34;type&#34;] == Variable.S_TYPE_UNSUPPORTED:
        series_description.update(describe_unsupported(series, series_description))
    else:
        series_description.update(describe_supported(series, series_description))

        type_to_func = {
            Variable.TYPE_BOOL: describe_boolean_1d,
            Variable.TYPE_NUM: describe_numeric_1d,
            Variable.TYPE_DATE: describe_date_1d,
            Variable.TYPE_CAT: describe_categorical_1d,
            Variable.TYPE_URL: describe_url_1d,
            Variable.TYPE_PATH: describe_path_1d,
        }

        if series_description[&#34;type&#34;] in type_to_func:
            series_description.update(
                type_to_func[series_description[&#34;type&#34;]](series, series_description)
            )
        else:
            raise ValueError(&#34;Unexpected type&#34;)

    # Return the description obtained
    return series_description


def multiprocess_1d(column, series) -&gt; Tuple[str, dict]:
    &#34;&#34;&#34;Wrapper to process series in parallel.

    Args:
        column: The name of the column.
        series: The series values.

    Returns:
        A tuple with column and the series description.
    &#34;&#34;&#34;
    return column, describe_1d(series)


def describe_table(df: pd.DataFrame, variable_stats: pd.DataFrame) -&gt; dict:
    &#34;&#34;&#34;General statistics for the DataFrame.

    Args:
      df: The DataFrame to describe.
      variable_stats: Previously calculated statistic on the DataFrame.

    Returns:
        A dictionary that contains the table statistics.
    &#34;&#34;&#34;
    n = len(df)

    memory_size = df.memory_usage(index=True, deep=True).sum()
    record_size = float(memory_size) / n

    table_stats = {
        &#34;n&#34;: n,
        &#34;n_var&#34;: len(df.columns),
        &#34;memory_size&#34;: memory_size,
        &#34;record_size&#34;: record_size,
        &#34;n_cells_missing&#34;: variable_stats.loc[&#34;n_missing&#34;].sum(),
        &#34;n_vars_with_missing&#34;: sum((variable_stats.loc[&#34;n_missing&#34;] &gt; 0).astype(int)),
        &#34;n_vars_all_missing&#34;: sum((variable_stats.loc[&#34;n_missing&#34;] == n).astype(int)),
    }

    table_stats[&#34;p_cells_missing&#34;] = table_stats[&#34;n_cells_missing&#34;] / (
        table_stats[&#34;n&#34;] * table_stats[&#34;n_var&#34;]
    )

    supported_columns = variable_stats.transpose()[
        variable_stats.transpose().type != Variable.S_TYPE_UNSUPPORTED
    ].index.tolist()
    table_stats[&#34;n_duplicates&#34;] = (
        sum(df.duplicated(subset=supported_columns))
        if len(supported_columns) &gt; 0
        else 0
    )
    table_stats[&#34;p_duplicates&#34;] = (
        (table_stats[&#34;n_duplicates&#34;] / len(df))
        if (len(supported_columns) &gt; 0 and len(df) &gt; 0)
        else 0
    )

    # Variable type counts
    table_stats.update({k.value: 0 for k in Variable})
    table_stats.update(
        {
            &#34;types&#34;: dict(
                variable_stats.loc[&#34;type&#34;].apply(lambda x: x.value).value_counts()
            )
        }
    )

    return table_stats


def warn_missing(missing_name, error):
    warnings.warn(
        &#34;There was an attempt to generate the {missing_name} missing values diagrams, but this failed.\n&#34;
        &#34;To hide this warning, disable the calculation\n&#34;
        &#39;(using `df.profile_report(missing_diagrams={{&#34;{missing_name}&#34;: False}}`)\n&#39;
        &#34;If this is problematic for your use case, please report this as an issue:\n&#34;
        &#34;https://github.com/pandas-profiling/pandas-profiling/issues\n&#34;
        &#34;(include the error message: &#39;{error}&#39;)&#34;.format(
            missing_name=missing_name, error=error
        )
    )


def get_missing_diagrams(df: pd.DataFrame, table_stats: dict) -&gt; dict:
    &#34;&#34;&#34;Gets the rendered diagrams for missing values.

    Args:
        table_stats: The overall statistics for the DataFrame.
        df: The DataFrame on which to calculate the missing values.

    Returns:
        A dictionary containing the base64 encoded plots for each diagram that is active in the config (matrix, bar, heatmap, dendrogram).
    &#34;&#34;&#34;
    missing_map = {
        &#34;bar&#34;: {&#34;func&#34;: missing_bar, &#34;min_missing&#34;: 0, &#34;name&#34;: &#34;Count&#34;},
        &#34;matrix&#34;: {&#34;func&#34;: missing_matrix, &#34;min_missing&#34;: 0, &#34;name&#34;: &#34;Matrix&#34;},
        &#34;heatmap&#34;: {&#34;func&#34;: missing_heatmap, &#34;min_missing&#34;: 2, &#34;name&#34;: &#34;Heatmap&#34;},
        &#34;dendrogram&#34;: {
            &#34;func&#34;: missing_dendrogram,
            &#34;min_missing&#34;: 1,
            &#34;name&#34;: &#34;Dendrogram&#34;,
        },
    }

    missing = {}
    for name, settings in missing_map.items():
        if (
            config[&#34;missing_diagrams&#34;][name].get(bool)
            and table_stats[&#34;n_vars_with_missing&#34;] &gt;= settings[&#34;min_missing&#34;]
        ):
            try:
                if name != &#34;heatmap&#34; or (
                    table_stats[&#34;n_vars_with_missing&#34;]
                    - table_stats[&#34;n_vars_all_missing&#34;]
                    &gt;= settings[&#34;min_missing&#34;]
                ):
                    missing[name] = {
                        &#34;name&#34;: settings[&#34;name&#34;],
                        &#34;matrix&#34;: settings[&#34;func&#34;](df),
                    }
            except ValueError as e:
                warn_missing(name, e)
    return missing


def get_scatter_matrix(df, variables):
    if config[&#34;interactions&#34;][&#34;continuous&#34;].get(bool):
        continuous_variables = [
            column for column, type in variables.items() if type == Variable.TYPE_NUM
        ]

        scatter_matrix = {
            x: {y: &#34;&#34; for y in continuous_variables} for x in continuous_variables
        }
        for x in continuous_variables:
            for y in continuous_variables:
                scatter_matrix[x][y] = scatter_pairwise(df[x], df[y], x, y)
    else:
        scatter_matrix = {}

    return scatter_matrix


def describe(df: pd.DataFrame) -&gt; dict:
    &#34;&#34;&#34;Calculate the statistics for each series in this DataFrame.

    Args:
        df: DataFrame.

    Returns:
        This function returns a dictionary containing:
            - table: overall statistics.
            - variables: descriptions per series.
            - correlations: correlation matrices.
            - missing: missing value diagrams.
            - messages: direct special attention to these patterns in your data.
    &#34;&#34;&#34;
    if not isinstance(df, pd.DataFrame):
        raise TypeError(&#34;df must be of type pandas.DataFrame&#34;)

    if df.empty:
        raise ValueError(&#34;df can not be empty&#34;)

    # Multiprocessing of Describe 1D for each column
    pool_size = config[&#34;pool_size&#34;].get(int)
    if pool_size &lt;= 0:
        pool_size = multiprocessing.cpu_count()

    if pool_size == 1:
        args = [(column, series) for column, series in df.iteritems()]
        series_description = {
            column: series
            for column, series in itertools.starmap(multiprocess_1d, args)
        }
    else:
        with multiprocessing.pool.ThreadPool(pool_size) as executor:
            series_description = {}
            results = executor.starmap(multiprocess_1d, df.iteritems())
            for col, description in results:
                series_description[col] = description

    # Mapping from column name to variable type
    variables = {
        column: description[&#34;type&#34;]
        for column, description in series_description.items()
    }

    # Get correlations
    correlations = calculate_correlations(df, variables)

    # Scatter matrix
    scatter_matrix = get_scatter_matrix(df, variables)

    # Transform the series_description in a DataFrame
    variable_stats = pd.DataFrame(series_description)

    # Table statistics
    table_stats = describe_table(df, variable_stats)

    # missing diagrams
    missing = get_missing_diagrams(df, table_stats)

    # Messages
    messages = check_table_messages(table_stats)
    for col, description in series_description.items():
        messages += check_variable_messages(col, description)

    messages += check_correlation_messages(correlations)

    package = {
        &#34;pandas_profiling_version&#34;: __version__,
        &#34;pandas_profiling_config&#34;: config.dump(),
    }

    return {
        # Overall description
        &#34;table&#34;: table_stats,
        # Per variable descriptions
        &#34;variables&#34;: series_description,
        # Bivariate relations
        &#34;scatter&#34;: scatter_matrix,
        # Correlation matrices
        &#34;correlations&#34;: correlations,
        # Missing values
        &#34;missing&#34;: missing,
        # Warnings
        &#34;messages&#34;: messages,
        # Package
        &#34;package&#34;: package,
    }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pandas_profiling.model.describe.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>df)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate the statistics for each series in this DataFrame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>DataFrame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>This</code> <code>function</code> <code>returns</code> <code>a</code> <code>dictionary</code> <code>containing</code>:</dt>
<dd>
<ul>
<li>table: overall statistics.</li>
<li>variables: descriptions per series.</li>
<li>correlations: correlation matrices.</li>
<li>missing: missing value diagrams.</li>
<li>messages: direct special attention to these patterns in your data.</li>
</ul>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(df: pd.DataFrame) -&gt; dict:
    &#34;&#34;&#34;Calculate the statistics for each series in this DataFrame.

    Args:
        df: DataFrame.

    Returns:
        This function returns a dictionary containing:
            - table: overall statistics.
            - variables: descriptions per series.
            - correlations: correlation matrices.
            - missing: missing value diagrams.
            - messages: direct special attention to these patterns in your data.
    &#34;&#34;&#34;
    if not isinstance(df, pd.DataFrame):
        raise TypeError(&#34;df must be of type pandas.DataFrame&#34;)

    if df.empty:
        raise ValueError(&#34;df can not be empty&#34;)

    # Multiprocessing of Describe 1D for each column
    pool_size = config[&#34;pool_size&#34;].get(int)
    if pool_size &lt;= 0:
        pool_size = multiprocessing.cpu_count()

    if pool_size == 1:
        args = [(column, series) for column, series in df.iteritems()]
        series_description = {
            column: series
            for column, series in itertools.starmap(multiprocess_1d, args)
        }
    else:
        with multiprocessing.pool.ThreadPool(pool_size) as executor:
            series_description = {}
            results = executor.starmap(multiprocess_1d, df.iteritems())
            for col, description in results:
                series_description[col] = description

    # Mapping from column name to variable type
    variables = {
        column: description[&#34;type&#34;]
        for column, description in series_description.items()
    }

    # Get correlations
    correlations = calculate_correlations(df, variables)

    # Scatter matrix
    scatter_matrix = get_scatter_matrix(df, variables)

    # Transform the series_description in a DataFrame
    variable_stats = pd.DataFrame(series_description)

    # Table statistics
    table_stats = describe_table(df, variable_stats)

    # missing diagrams
    missing = get_missing_diagrams(df, table_stats)

    # Messages
    messages = check_table_messages(table_stats)
    for col, description in series_description.items():
        messages += check_variable_messages(col, description)

    messages += check_correlation_messages(correlations)

    package = {
        &#34;pandas_profiling_version&#34;: __version__,
        &#34;pandas_profiling_config&#34;: config.dump(),
    }

    return {
        # Overall description
        &#34;table&#34;: table_stats,
        # Per variable descriptions
        &#34;variables&#34;: series_description,
        # Bivariate relations
        &#34;scatter&#34;: scatter_matrix,
        # Correlation matrices
        &#34;correlations&#34;: correlations,
        # Missing values
        &#34;missing&#34;: missing,
        # Warnings
        &#34;messages&#34;: messages,
        # Package
        &#34;package&#34;: package,
    }</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.describe_1d"><code class="name flex">
<span>def <span class="ident">describe_1d</span></span>(<span>series)</span>
</code></dt>
<dd>
<section class="desc"><p>Describe a series (infer the variable type, then calculate type-specific values).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>series</code></strong></dt>
<dd>The Series to describe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Series containing calculated series description values.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_1d(series: pd.Series) -&gt; dict:
    &#34;&#34;&#34;Describe a series (infer the variable type, then calculate type-specific values).

    Args:
        series: The Series to describe.

    Returns:
        A Series containing calculated series description values.
    &#34;&#34;&#34;

    # Replace infinite values with NaNs to avoid issues with histograms later.
    series.replace(to_replace=[np.inf, np.NINF, np.PINF], value=np.nan, inplace=True)

    # Infer variable types
    series_description = base.get_var_type(series)

    # Run type specific analysis
    if series_description[&#34;type&#34;] == Variable.S_TYPE_UNSUPPORTED:
        series_description.update(describe_unsupported(series, series_description))
    else:
        series_description.update(describe_supported(series, series_description))

        type_to_func = {
            Variable.TYPE_BOOL: describe_boolean_1d,
            Variable.TYPE_NUM: describe_numeric_1d,
            Variable.TYPE_DATE: describe_date_1d,
            Variable.TYPE_CAT: describe_categorical_1d,
            Variable.TYPE_URL: describe_url_1d,
            Variable.TYPE_PATH: describe_path_1d,
        }

        if series_description[&#34;type&#34;] in type_to_func:
            series_description.update(
                type_to_func[series_description[&#34;type&#34;]](series, series_description)
            )
        else:
            raise ValueError(&#34;Unexpected type&#34;)

    # Return the description obtained
    return series_description</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.describe_boolean_1d"><code class="name flex">
<span>def <span class="ident">describe_boolean_1d</span></span>(<span>series, series_description)</span>
</code></dt>
<dd>
<section class="desc"><p>Describe a boolean series.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>series</code></strong></dt>
<dd>The Series to describe.</dd>
<dt><strong><code>series_description</code></strong></dt>
<dd>The dict containing the series description so far.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dict containing calculated series description values.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_boolean_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a boolean series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;
    value_counts = series_description[&#34;value_counts_without_nan&#34;]

    stats = {&#34;top&#34;: value_counts.index[0], &#34;freq&#34;: value_counts.iloc[0]}

    return stats</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.describe_categorical_1d"><code class="name flex">
<span>def <span class="ident">describe_categorical_1d</span></span>(<span>series, series_description)</span>
</code></dt>
<dd>
<section class="desc"><p>Describe a categorical series.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>series</code></strong></dt>
<dd>The Series to describe.</dd>
<dt><strong><code>series_description</code></strong></dt>
<dd>The dict containing the series description so far.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dict containing calculated series description values.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_categorical_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a categorical series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;
    # Make sure we deal with strings (Issue #100)
    series = series.astype(str)

    # Only run if at least 1 non-missing value
    value_counts = series_description[&#34;value_counts_without_nan&#34;]

    stats = {&#34;top&#34;: value_counts.index[0], &#34;freq&#34;: value_counts.iloc[0]}

    chi_squared_threshold = config[&#34;vars&#34;][&#34;num&#34;][&#34;chi_squared_threshold&#34;].get(float)
    if chi_squared_threshold &gt; 0.0:
        stats[&#34;chi_squared&#34;] = list(chisquare(value_counts.values))

    check_composition = config[&#34;vars&#34;][&#34;cat&#34;][&#34;check_composition&#34;].get(bool)
    if check_composition:
        contains = {
            &#34;chars&#34;: series.str.contains(r&#34;[a-zA-Z]&#34;, case=False, regex=True).any(),
            &#34;digits&#34;: series.str.contains(r&#34;[0-9]&#34;, case=False, regex=True).any(),
            &#34;spaces&#34;: series.str.contains(r&#34;\s&#34;, case=False, regex=True).any(),
            &#34;non-words&#34;: series.str.contains(r&#34;\W&#34;, case=False, regex=True).any(),
        }

        stats[&#34;length&#34;] = series.str.len()
        stats[&#34;max_length&#34;] = series.str.len().max()
        stats[&#34;mean_length&#34;] = series.str.len().mean()
        stats[&#34;min_length&#34;] = series.str.len().min()
        stats[&#34;composition&#34;] = contains

    stats[&#34;date_warning&#34;] = warning_type_date(series)

    return stats</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.describe_date_1d"><code class="name flex">
<span>def <span class="ident">describe_date_1d</span></span>(<span>series, series_description)</span>
</code></dt>
<dd>
<section class="desc"><p>Describe a date series.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>series</code></strong></dt>
<dd>The Series to describe.</dd>
<dt><strong><code>series_description</code></strong></dt>
<dd>The dict containing the series description so far.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dict containing calculated series description values.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_date_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a date series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;
    stats = {&#34;min&#34;: series.min(), &#34;max&#34;: series.max(), &#34;histogram_data&#34;: series}

    bins = config[&#34;plot&#34;][&#34;histogram&#34;][&#34;bins&#34;].get(int)
    # Bins should never be larger than the number of distinct values
    bins = min(series_description[&#34;distinct_count_with_nan&#34;], bins)
    stats[&#34;histogram_bins&#34;] = bins

    stats[&#34;range&#34;] = stats[&#34;max&#34;] - stats[&#34;min&#34;]

    return stats</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.describe_numeric_1d"><code class="name flex">
<span>def <span class="ident">describe_numeric_1d</span></span>(<span>series, series_description)</span>
</code></dt>
<dd>
<section class="desc"><p>Describe a numeric series.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>series</code></strong></dt>
<dd>The Series to describe.</dd>
<dt><strong><code>series_description</code></strong></dt>
<dd>The dict containing the series description so far.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dict containing calculated series description values.</p>
<h2 id="notes">Notes</h2>
<p>When 'bins_type' is set to 'bayesian_blocks', astropy.stats.bayesian_blocks is used to determine the number of
bins. Read the docs:
<a href="https://docs.astropy.org/en/stable/visualization/histogram.html">https://docs.astropy.org/en/stable/visualization/histogram.html</a>
<a href="https://docs.astropy.org/en/stable/api/astropy.stats.bayesian_blocks.html">https://docs.astropy.org/en/stable/api/astropy.stats.bayesian_blocks.html</a></p>
<p>This method might print warnings, which we suppress.
<a href="https://github.com/astropy/astropy/issues/4927">https://github.com/astropy/astropy/issues/4927</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_numeric_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a numeric series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.

    Notes:
        When &#39;bins_type&#39; is set to &#39;bayesian_blocks&#39;, astropy.stats.bayesian_blocks is used to determine the number of
        bins. Read the docs:
        https://docs.astropy.org/en/stable/visualization/histogram.html
        https://docs.astropy.org/en/stable/api/astropy.stats.bayesian_blocks.html

        This method might print warnings, which we suppress.
        https://github.com/astropy/astropy/issues/4927
    &#34;&#34;&#34;
    quantiles = config[&#34;vars&#34;][&#34;num&#34;][&#34;quantiles&#34;].get(list)

    stats = {
        &#34;mean&#34;: series.mean(),
        &#34;std&#34;: series.std(),
        &#34;variance&#34;: series.var(),
        &#34;min&#34;: series.min(),
        &#34;max&#34;: series.max(),
        &#34;kurtosis&#34;: series.kurt(),
        &#34;skewness&#34;: series.skew(),
        &#34;sum&#34;: series.sum(),
        &#34;mad&#34;: series.mad(),
        &#34;n_zeros&#34;: (len(series) - np.count_nonzero(series)),
        &#34;histogram_data&#34;: series,
        &#34;scatter_data&#34;: series,  # For complex
    }

    chi_squared_threshold = config[&#34;vars&#34;][&#34;num&#34;][&#34;chi_squared_threshold&#34;].get(float)
    if chi_squared_threshold &gt; 0.0:
        histogram = np.histogram(series[series.notna()].values, bins=&#34;auto&#34;)[0]
        stats[&#34;chi_squared&#34;] = chisquare(histogram)

    stats[&#34;range&#34;] = stats[&#34;max&#34;] - stats[&#34;min&#34;]
    stats.update(
        {
            &#34;{:.0%}&#34;.format(percentile): value
            for percentile, value in series.quantile(quantiles).to_dict().items()
        }
    )
    stats[&#34;iqr&#34;] = stats[&#34;75%&#34;] - stats[&#34;25%&#34;]
    stats[&#34;cv&#34;] = stats[&#34;std&#34;] / stats[&#34;mean&#34;] if stats[&#34;mean&#34;] else np.NaN
    stats[&#34;p_zeros&#34;] = float(stats[&#34;n_zeros&#34;]) / len(series)

    bins = config[&#34;plot&#34;][&#34;histogram&#34;][&#34;bins&#34;].get(int)
    # Bins should never be larger than the number of distinct values
    bins = min(series_description[&#34;distinct_count_with_nan&#34;], bins)
    stats[&#34;histogram_bins&#34;] = bins

    bayesian_blocks_bins = config[&#34;plot&#34;][&#34;histogram&#34;][&#34;bayesian_blocks_bins&#34;].get(bool)
    if bayesian_blocks_bins:
        with warnings.catch_warnings():
            warnings.simplefilter(&#34;ignore&#34;)
            ret = bayesian_blocks(stats[&#34;histogram_data&#34;])

            # Sanity check
            if not np.isnan(ret).any() and ret.size &gt; 1:
                stats[&#34;histogram_bins_bayesian_blocks&#34;] = ret

    return stats</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.describe_path_1d"><code class="name flex">
<span>def <span class="ident">describe_path_1d</span></span>(<span>series, series_description)</span>
</code></dt>
<dd>
<section class="desc"><p>Describe a path series.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>series</code></strong></dt>
<dd>The Series to describe.</dd>
<dt><strong><code>series_description</code></strong></dt>
<dd>The dict containing the series description so far.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dict containing calculated series description values.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_path_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a path series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;
    series_description.update(describe_categorical_1d(series, series_description))

    # Make sure we deal with strings (Issue #100)
    series = series[~series.isnull()].astype(str)
    series = series.map(Path)

    common_prefix = os.path.commonprefix(list(series))
    if common_prefix == &#34;&#34;:
        common_prefix = &#34;No common prefix&#34;

    stats = {&#34;common_prefix&#34;: common_prefix}

    # Create separate columns for each path part
    keys = [&#34;stem&#34;, &#34;suffix&#34;, &#34;name&#34;, &#34;parent&#34;]
    path_parts = dict(
        zip(keys, zip(*series.map(lambda x: [x.stem, x.suffix, x.name, x.parent])))
    )
    for name, part in path_parts.items():
        stats[&#34;{}_counts&#34;.format(name.lower())] = pd.Series(
            part, name=name
        ).value_counts()

    # Only run if at least 1 non-missing value
    value_counts = series_description[&#34;value_counts_without_nan&#34;]

    stats[&#34;top&#34;] = value_counts.index[0]
    stats[&#34;freq&#34;] = value_counts.iloc[0]

    return stats</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.describe_supported"><code class="name flex">
<span>def <span class="ident">describe_supported</span></span>(<span>series, series_description)</span>
</code></dt>
<dd>
<section class="desc"><p>Describe a supported series.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>series</code></strong></dt>
<dd>The Series to describe.</dd>
<dt><strong><code>series_description</code></strong></dt>
<dd>The dict containing the series description so far.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dict containing calculated series description values.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_supported(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a supported series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;

    # number of observations in the Series
    leng = len(series)
    # TODO: fix infinite logic
    # number of non-NaN observations in the Series
    count = series.count()
    # number of infinite observations in the Series
    n_infinite = count - series.count()

    # TODO: check if we prefer without nan
    distinct_count = series_description[&#34;distinct_count_with_nan&#34;]

    stats = {
        &#34;n&#34;: leng,
        &#34;count&#34;: count,
        &#34;distinct_count&#34;: distinct_count,
        &#34;n_unique&#34;: distinct_count,
        &#34;p_missing&#34;: 1 - count * 1.0 / leng,
        &#34;n_missing&#34;: leng - count,
        &#34;p_infinite&#34;: n_infinite * 1.0 / leng,
        &#34;n_infinite&#34;: n_infinite,
        &#34;is_unique&#34;: distinct_count == leng,
        &#34;mode&#34;: series.mode().iloc[0] if count &gt; distinct_count &gt; 1 else series[0],
        &#34;p_unique&#34;: distinct_count * 1.0 / leng,
        &#34;memory_size&#34;: series.memory_usage(),
    }

    return stats</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.describe_table"><code class="name flex">
<span>def <span class="ident">describe_table</span></span>(<span>df, variable_stats)</span>
</code></dt>
<dd>
<section class="desc"><p>General statistics for the DataFrame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>The DataFrame to describe.</dd>
<dt><strong><code>variable_stats</code></strong></dt>
<dd>Previously calculated statistic on the DataFrame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary that contains the table statistics.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_table(df: pd.DataFrame, variable_stats: pd.DataFrame) -&gt; dict:
    &#34;&#34;&#34;General statistics for the DataFrame.

    Args:
      df: The DataFrame to describe.
      variable_stats: Previously calculated statistic on the DataFrame.

    Returns:
        A dictionary that contains the table statistics.
    &#34;&#34;&#34;
    n = len(df)

    memory_size = df.memory_usage(index=True, deep=True).sum()
    record_size = float(memory_size) / n

    table_stats = {
        &#34;n&#34;: n,
        &#34;n_var&#34;: len(df.columns),
        &#34;memory_size&#34;: memory_size,
        &#34;record_size&#34;: record_size,
        &#34;n_cells_missing&#34;: variable_stats.loc[&#34;n_missing&#34;].sum(),
        &#34;n_vars_with_missing&#34;: sum((variable_stats.loc[&#34;n_missing&#34;] &gt; 0).astype(int)),
        &#34;n_vars_all_missing&#34;: sum((variable_stats.loc[&#34;n_missing&#34;] == n).astype(int)),
    }

    table_stats[&#34;p_cells_missing&#34;] = table_stats[&#34;n_cells_missing&#34;] / (
        table_stats[&#34;n&#34;] * table_stats[&#34;n_var&#34;]
    )

    supported_columns = variable_stats.transpose()[
        variable_stats.transpose().type != Variable.S_TYPE_UNSUPPORTED
    ].index.tolist()
    table_stats[&#34;n_duplicates&#34;] = (
        sum(df.duplicated(subset=supported_columns))
        if len(supported_columns) &gt; 0
        else 0
    )
    table_stats[&#34;p_duplicates&#34;] = (
        (table_stats[&#34;n_duplicates&#34;] / len(df))
        if (len(supported_columns) &gt; 0 and len(df) &gt; 0)
        else 0
    )

    # Variable type counts
    table_stats.update({k.value: 0 for k in Variable})
    table_stats.update(
        {
            &#34;types&#34;: dict(
                variable_stats.loc[&#34;type&#34;].apply(lambda x: x.value).value_counts()
            )
        }
    )

    return table_stats</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.describe_unsupported"><code class="name flex">
<span>def <span class="ident">describe_unsupported</span></span>(<span>series, series_description)</span>
</code></dt>
<dd>
<section class="desc"><p>Describe an unsupported series.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>series</code></strong></dt>
<dd>The Series to describe.</dd>
<dt><strong><code>series_description</code></strong></dt>
<dd>The dict containing the series description so far.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dict containing calculated series description values.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_unsupported(series: pd.Series, series_description: dict):
    &#34;&#34;&#34;Describe an unsupported series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;

    # number of observations in the Series
    leng = len(series)
    # number of non-NaN observations in the Series
    count = series.count()
    # number of infinte observations in the Series
    n_infinite = count - series.count()

    results_data = {
        &#34;n&#34;: leng,
        &#34;count&#34;: count,
        &#34;p_missing&#34;: 1 - count * 1.0 / leng,
        &#34;n_missing&#34;: leng - count,
        &#34;p_infinite&#34;: n_infinite * 1.0 / leng,
        &#34;n_infinite&#34;: n_infinite,
        &#34;memory_size&#34;: series.memory_usage(),
    }

    return results_data</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.describe_url_1d"><code class="name flex">
<span>def <span class="ident">describe_url_1d</span></span>(<span>series, series_description)</span>
</code></dt>
<dd>
<section class="desc"><p>Describe a url series.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>series</code></strong></dt>
<dd>The Series to describe.</dd>
<dt><strong><code>series_description</code></strong></dt>
<dd>The dict containing the series description so far.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dict containing calculated series description values.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_url_1d(series: pd.Series, series_description: dict) -&gt; dict:
    &#34;&#34;&#34;Describe a url series.

    Args:
        series: The Series to describe.
        series_description: The dict containing the series description so far.

    Returns:
        A dict containing calculated series description values.
    &#34;&#34;&#34;
    # Make sure we deal with strings (Issue #100)
    series = series[~series.isnull()].astype(str)

    stats = {}

    # Create separate columns for each URL part
    keys = [&#34;scheme&#34;, &#34;netloc&#34;, &#34;path&#34;, &#34;query&#34;, &#34;fragment&#34;]
    url_parts = dict(zip(keys, zip(*series.map(urlsplit))))
    for name, part in url_parts.items():
        stats[&#34;{}_counts&#34;.format(name.lower())] = pd.Series(
            part, name=name
        ).value_counts()

    # Only run if at least 1 non-missing value
    value_counts = series_description[&#34;value_counts_without_nan&#34;]

    stats[&#34;top&#34;] = value_counts.index[0]
    stats[&#34;freq&#34;] = value_counts.iloc[0]

    return stats</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.get_missing_diagrams"><code class="name flex">
<span>def <span class="ident">get_missing_diagrams</span></span>(<span>df, table_stats)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the rendered diagrams for missing values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>table_stats</code></strong></dt>
<dd>The overall statistics for the DataFrame.</dd>
<dt><strong><code>df</code></strong></dt>
<dd>The DataFrame on which to calculate the missing values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary containing the base64 encoded plots for each diagram that is active in the config (matrix, bar, heatmap, dendrogram).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_missing_diagrams(df: pd.DataFrame, table_stats: dict) -&gt; dict:
    &#34;&#34;&#34;Gets the rendered diagrams for missing values.

    Args:
        table_stats: The overall statistics for the DataFrame.
        df: The DataFrame on which to calculate the missing values.

    Returns:
        A dictionary containing the base64 encoded plots for each diagram that is active in the config (matrix, bar, heatmap, dendrogram).
    &#34;&#34;&#34;
    missing_map = {
        &#34;bar&#34;: {&#34;func&#34;: missing_bar, &#34;min_missing&#34;: 0, &#34;name&#34;: &#34;Count&#34;},
        &#34;matrix&#34;: {&#34;func&#34;: missing_matrix, &#34;min_missing&#34;: 0, &#34;name&#34;: &#34;Matrix&#34;},
        &#34;heatmap&#34;: {&#34;func&#34;: missing_heatmap, &#34;min_missing&#34;: 2, &#34;name&#34;: &#34;Heatmap&#34;},
        &#34;dendrogram&#34;: {
            &#34;func&#34;: missing_dendrogram,
            &#34;min_missing&#34;: 1,
            &#34;name&#34;: &#34;Dendrogram&#34;,
        },
    }

    missing = {}
    for name, settings in missing_map.items():
        if (
            config[&#34;missing_diagrams&#34;][name].get(bool)
            and table_stats[&#34;n_vars_with_missing&#34;] &gt;= settings[&#34;min_missing&#34;]
        ):
            try:
                if name != &#34;heatmap&#34; or (
                    table_stats[&#34;n_vars_with_missing&#34;]
                    - table_stats[&#34;n_vars_all_missing&#34;]
                    &gt;= settings[&#34;min_missing&#34;]
                ):
                    missing[name] = {
                        &#34;name&#34;: settings[&#34;name&#34;],
                        &#34;matrix&#34;: settings[&#34;func&#34;](df),
                    }
            except ValueError as e:
                warn_missing(name, e)
    return missing</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.get_scatter_matrix"><code class="name flex">
<span>def <span class="ident">get_scatter_matrix</span></span>(<span>df, variables)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scatter_matrix(df, variables):
    if config[&#34;interactions&#34;][&#34;continuous&#34;].get(bool):
        continuous_variables = [
            column for column, type in variables.items() if type == Variable.TYPE_NUM
        ]

        scatter_matrix = {
            x: {y: &#34;&#34; for y in continuous_variables} for x in continuous_variables
        }
        for x in continuous_variables:
            for y in continuous_variables:
                scatter_matrix[x][y] = scatter_pairwise(df[x], df[y], x, y)
    else:
        scatter_matrix = {}

    return scatter_matrix</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.multiprocess_1d"><code class="name flex">
<span>def <span class="ident">multiprocess_1d</span></span>(<span>column, series)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper to process series in parallel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong></dt>
<dd>The name of the column.</dd>
<dt><strong><code>series</code></strong></dt>
<dd>The series values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple with column and the series description.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiprocess_1d(column, series) -&gt; Tuple[str, dict]:
    &#34;&#34;&#34;Wrapper to process series in parallel.

    Args:
        column: The name of the column.
        series: The series values.

    Returns:
        A tuple with column and the series description.
    &#34;&#34;&#34;
    return column, describe_1d(series)</code></pre>
</details>
</dd>
<dt id="pandas_profiling.model.describe.warn_missing"><code class="name flex">
<span>def <span class="ident">warn_missing</span></span>(<span>missing_name, error)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def warn_missing(missing_name, error):
    warnings.warn(
        &#34;There was an attempt to generate the {missing_name} missing values diagrams, but this failed.\n&#34;
        &#34;To hide this warning, disable the calculation\n&#34;
        &#39;(using `df.profile_report(missing_diagrams={{&#34;{missing_name}&#34;: False}}`)\n&#39;
        &#34;If this is problematic for your use case, please report this as an issue:\n&#34;
        &#34;https://github.com/pandas-profiling/pandas-profiling/issues\n&#34;
        &#34;(include the error message: &#39;{error}&#39;)&#34;.format(
            missing_name=missing_name, error=error
        )
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pandas_profiling.model" href="index.html">pandas_profiling.model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pandas_profiling.model.describe.describe" href="#pandas_profiling.model.describe.describe">describe</a></code></li>
<li><code><a title="pandas_profiling.model.describe.describe_1d" href="#pandas_profiling.model.describe.describe_1d">describe_1d</a></code></li>
<li><code><a title="pandas_profiling.model.describe.describe_boolean_1d" href="#pandas_profiling.model.describe.describe_boolean_1d">describe_boolean_1d</a></code></li>
<li><code><a title="pandas_profiling.model.describe.describe_categorical_1d" href="#pandas_profiling.model.describe.describe_categorical_1d">describe_categorical_1d</a></code></li>
<li><code><a title="pandas_profiling.model.describe.describe_date_1d" href="#pandas_profiling.model.describe.describe_date_1d">describe_date_1d</a></code></li>
<li><code><a title="pandas_profiling.model.describe.describe_numeric_1d" href="#pandas_profiling.model.describe.describe_numeric_1d">describe_numeric_1d</a></code></li>
<li><code><a title="pandas_profiling.model.describe.describe_path_1d" href="#pandas_profiling.model.describe.describe_path_1d">describe_path_1d</a></code></li>
<li><code><a title="pandas_profiling.model.describe.describe_supported" href="#pandas_profiling.model.describe.describe_supported">describe_supported</a></code></li>
<li><code><a title="pandas_profiling.model.describe.describe_table" href="#pandas_profiling.model.describe.describe_table">describe_table</a></code></li>
<li><code><a title="pandas_profiling.model.describe.describe_unsupported" href="#pandas_profiling.model.describe.describe_unsupported">describe_unsupported</a></code></li>
<li><code><a title="pandas_profiling.model.describe.describe_url_1d" href="#pandas_profiling.model.describe.describe_url_1d">describe_url_1d</a></code></li>
<li><code><a title="pandas_profiling.model.describe.get_missing_diagrams" href="#pandas_profiling.model.describe.get_missing_diagrams">get_missing_diagrams</a></code></li>
<li><code><a title="pandas_profiling.model.describe.get_scatter_matrix" href="#pandas_profiling.model.describe.get_scatter_matrix">get_scatter_matrix</a></code></li>
<li><code><a title="pandas_profiling.model.describe.multiprocess_1d" href="#pandas_profiling.model.describe.multiprocess_1d">multiprocess_1d</a></code></li>
<li><code><a title="pandas_profiling.model.describe.warn_missing" href="#pandas_profiling.model.describe.warn_missing">warn_missing</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>